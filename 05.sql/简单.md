```sql
# 创建数据库
CREATE DATABASE dbname CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
```

## 联结

**orders 表格**

| order_id | customer_id | order_date | amount |
| -------- | ----------- | ---------- | ------ |
| 1        | 100         | 2022-01-01 | 100    |
| 2        | 200         | 2022-01-02 | 200    |
| 3        | 100         | 2022-01-03 | 300    |
| 4        | 300         | 2022-01-04 | 400    |

**customers 表格**

| customer_id | name    |
| ----------- | ------- |
| 100         | Alice   |
| 200         | Bob     |
| 300         | Charlie |
| 400         | David   |

#### 内联结 Inner Join

只有当连接条件在两个表中都有匹配的行时，才会将这两行合并到一起

inner join 可以简化为 join

```sql
SELECT orders.order_id, orders.order_date, orders.amount, customers.name
FROM orders
INNER JOIN customers ON orders.customer_id = customers.customer_id;
```

| order_id | order_date | amount | name    |
| -------- | ---------- | ------ | ------- |
| 1        | 2022-01-01 | 100    | Alice   |
| 2        | 2022-01-02 | 200    | Bob     |
| 3        | 2022-01-03 | 300    | Alice   |
| 4        | 2022-01-04 | 400    | Charlie |

> INNER JOIN 只返回两个表格中都存在的记录，因此我们只看到了 `orders` 表格中的前四条记录和 `customers` 表格中的前三条记录之间的匹配结果

#### 左外联结 Left Join

以左表为基础，将左表的所有行和右表中有匹配行的行合并到一起，如果右表中没有匹配行，则结果中填充 NULL 值

```sql
SELECT orders.order_id, orders.order_date, orders.amount, customers.name
FROM orders
LEFT JOIN customers ON orders.customer_id = customers.customer_id;
```

| order_id | order_date | amount | name    |
| -------- | ---------- | ------ | ------- |
| 1        | 2022-01-01 | 100    | Alice   |
| 2        | 2022-01-02 | 200    | Bob     |
| 3        | 2022-01-03 | 300    | Alice   |
| 4        | 2022-01-04 | 400    | Charlie |

#### 右外联结 Right Join

以右表为基础，将右表的所有行和左表中有匹配行的行合并到一起，如果左表中没有匹配行，则结果中填充 NULL 值

```sql
SELECT orders.order_id, orders.order_date, orders.amount, customers.name
FROM orders
RIGHT JOIN customers ON orders.customer_id = customers.customer_id;
```

| order_id | order_date | amount | name    |
| -------- | ---------- | ------ | ------- |
| 1        | 2022-01-01 | 100    | Alice   |
| 3        | 2022-01-03 | 300    | Alice   |
| 2        | 2022-01-02 | 200    | Bob     |
| 4        | 2022-01-04 | 400    | Charlie |
| NULL     | NULL       | NULL   | David   |

#### 全外联结 Full Outer Join

MySQL 并没有原生支持 Full Outer Join 操作 , 通过使用 UNION 和 LEFT JOIN/RIGHT JOIN 来模拟实现 Full Outer Join

```sql
SELECT orders.order_id, orders.order_date, orders.amount, customers.name
FROM orders
LEFT JOIN customers ON orders.customer_id = customers.customer_id
UNION
SELECT orders.order_id, orders.order_date, orders.amount, customers.name
FROM orders
RIGHT JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IS NULL;
```

| order_id | order_date | amount | name    |
| -------- | ---------- | ------ | ------- |
| 1        | 2022-01-01 | 100    | Alice   |
| 2        | 2022-01-02 | 200    | Bob     |
| 3        | 2022-01-03 | 300    | Alice   |
| 4        | 2022-01-04 | 400    | Charlie |
| NULL     | NULL       | NULL   | David   |

#### 自连接 Self Join

同一个表中进行联结操作, 常见的应用场景是表中有两个字段需要匹配

**employees 表格**

| emp_id | emp_name | emp_email                                         | manager_id |
| ------ | -------- | ------------------------------------------------- | ---------- |
| 1      | Alice    | [alice@example.com](mailto:alice@example.com)     | 2          |
| 2      | Bob      | [bob@example.com](mailto:bob@example.com)         | 3          |
| 3      | Charlie  | [charlie@example.com](mailto:charlie@example.com) | 3          |
| 4      | David    | [david@example.com](mailto:david@example.com)     | 2          |
| 5      | Eve      | [eve@example.com](mailto:eve@example.com)         | 3          |

上述表格中，`manager_id` 列指向员工所属的经理的 `emp_id`

假设我们需要查询每个员工的姓名以及其直接经理的姓名

```sql
SELECT e.emp_name AS employee_name, m.emp_name AS manager_name
FROM employees e
JOIN employees m ON e.manager_id = m.emp_id;
```

| employee_name | manager_name |
| ------------- | ------------ |
| Alice         | Bob          |
| Bob           | Charlie      |
| Charlie       | Charlie      |
| David         | Bob          |
| Eve           | Charlie      |

#### 交叉联结 Cross Join

也称为笛卡尔积（Cartesian Product），是一种联结方式，它将两个表格中的每个行与另一个表格中的所有行进行组合，从而生成一个新的表格

**table1 表格**

| id   | name  |
| ---- | ----- |
| 1    | Alice |
| 2    | Bob   |

**table2 表格**

| id   | age  |
| ---- | ---- |
| 1    | 20   |
| 2    | 30   |
| 3    | 40   |

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

| id   | name  | id   | age  |
| ---- | ----- | ---- | ---- |
| 1    | Alice | 1    | 20   |
| 1    | Alice | 2    | 30   |
| 1    | Alice | 3    | 40   |
| 2    | Bob   | 1    | 20   |
| 2    | Bob   | 2    | 30   |
| 2    | Bob   | 3    | 40   |

> 以上结果包含了 `table1` 和 `table2` 中的所有行组合。注意，交叉联结会生成一个非常大的结果集，因此在使用交叉联结时需要格外小心。

## 基础指令

### where

必须紧跟在FROM子句之后

需要在分组之前加条件

效率高于having

### group by

group by一般对分组之后的函数使用聚集函数汇总

最终展示的列, 只能是分组列和聚合列

### having

一般与group by组合来使用, 在汇总类的基础之上, 进一步筛选记录

HAVING子句只能在GROUP BY子句之后使用，因为它是用于筛选分组的

### order by

用于指定数据的排序方式

+ 升序 asc , 默认为升序, asc可以省略
+ 降序 desc

写在 where 之后,写在having之后,  limit之前

### limit

限定查询结果的`起始行`以及`查几行`

其中查询结果不包含起始行

### 子查询

每一个派生表, 都需要有自己的别名

## case when

```sql
# 查询
SELECT
    product_name,
    CASE 
        WHEN price < 50 THEN 'Low Price'
        WHEN price >= 50 AND price < 100 THEN 'Medium Price'
        ELSE 'High Price'
    END AS price_category
FROM products;
# 编辑
UPDATE students
SET status = 
    CASE
        WHEN grade >= 60 THEN 'Pass'
        ELSE 'Fail'
    END;
```

### 行转列

![image-20240424101646038](https://chenqf-blog-image.oss-cn-beijing.aliyuncs.com/images/image-20240424101646038.png)

```sql
# 公式
select  分组列,
		聚合函数(case 转换列 when 转换列值1 then 数据列 else ... end) as 列名1,
		聚合函数(case 转换列 when 转换列值2 then 数据列 else ... end) as 列名2,
from 表名
group by 分组列
```

### 列转行

![image-20240424103431744](https://chenqf-blog-image.oss-cn-beijing.aliyuncs.com/images/image-20240424103431744.png)

```sql
# 公式
SELECT 非转换列, '转换列1' AS 新转换列名, 转换列1 AS 新数据列名 FROM 表名
UNION ALL
SELECT 非转换列, '转换列2' AS 新转换列名, 转换列2 AS 新数据列名 FROM 表名
UNION ALL
SELECT 非转换列, '转换列3' AS 新转换列名, 转换列3 AS 新数据列名 FROM 表名
```

## 窗口函数

> mysql8 才支持

#### 基本含义

窗口限定一个范围, 可以理解为满足某些条件的记录集合 , 窗口函数也就是窗口范围内执行的函数

#### 基本语法

```sql
<函数名> over (partition by <分组的列> order by <排序的列> rows between <起始行> and <终止行>)
```

#### 分组子句

基于`PARTITION BY`生成静态窗口,上图中的上下两部分, 就是分割的两个静态窗口

不分组写成 PARTITION BY null , 或者直接不写

PARTITION BY 可以跟多个列, 如 partition by cid, sname

**`PARTITION BY`与`GROUP BY`的区别**

+ 前者不会压缩行数, 后者会
+ 后者只能选取分组的列和聚合的列

`GROUP BY 后生成的结果集与原表的行数和列数都不同`

#### 排序子句

不排序可以写成 order by null 或者直接不写

默认升序 asc 可以省略, desc 降序

可以跟随多个列, 如 order by cid, sname

*排序结果时将每个静态窗口进行排序*

#### 窗口子句

1. 起始行: N preceding / unbounded preceding
2. 当前行: current row
3. 终止行: N following / unbounded following

#### 例子

+ 2 preceding and 3 following 
  + 前2行到后三行
+ unbounded preceding and current row
  + 开头到当前行
+ unbounded preceding and unbounded following
  + 开头到结尾

#### 总结

+ 通过 partition by 和 order by 确定大窗口 (静态窗口)
+ 通过 row 子句针对每一行数据确定小窗口 (滑动窗口)
+ 对每行的小窗口内的数据执行函数并生成新的列

> `有排序子句`无窗口子句, 默认追加窗口子句:
>
> rows between unbounded preceding and current row

> `无排序子句`无窗口子句, 默认追加窗口子句:
>
> rows between unbounded preceding and unbounded following

### 函数

#### 排序类

+ row_number() : 非并列排名
  + 1 2 3
+ rank() : 跳跃排名 
  + 1 1 3
+ dense_rank() : 跳过, 但不跳跃排名
  + 1 1 2

```sql
# 以班级为组, 进行班级内排名
SELECT
	*, 
	row_number() over ( PARTITION BY cid ORDER BY score DESC ) AS '非并列排名',
	rank() over ( PARTITION BY cid ORDER BY score DESC ) AS '并列跳跃排名',
	dense_rank() over ( PARTITION BY cid ORDER BY score DESC ) AS '并列跳跃排名'
FROM
	student_score
```

#### 聚合类

+ sum 
+ count
+ avg
+ max
+ min

```sql
# 取每个班级的最大分数
SELECT
	*, 
	max(score) over ( PARTITION BY cid ) AS '最高分'
FROM
	student_score
```

#### 跨行类

+ lag - 滞后 - `向上偏移`
+ lead - 领先 - `向下偏移`

参数1: 比较的列

参数2: 偏移量

参数3: 找不到的默认值

```sql
# 同一班级内, 成绩比自己低一名的分数是多少
SELECT
	*, 
	lag(score,1) over ( PARTITION BY cid ORDER BY score ) AS '低一名的分数'
FROM
	student_score
```

```sql
# 统一班级内, 成绩比自己高2名的分数是多少
SELECT
	*, 
	lead(score,2) over ( PARTITION BY cid ORDER BY score ) AS '高2名的分数'
FROM
	student_score
```

### 归纳常见使用场景

> 分组内 top N

```sql
select * from
(
	select 
    	*, 
    	row_number() over (partition by <分组列> order by <比较列>) as rn 
    from <table-name>
)
where rn <= 3;
```

> 聚合分析问题

+ 通过窗口函数给原表添加中间列, 作为临时表
+ 在临时表中, 根据需分析的列和中间列做比较, 生成结果信息

> 连续问题

+ 行号过滤法
  + 通过row_number()生成连续行号
+ 错位比较法
  + 通过lag 和 lead 构造错位列, 再通过列进行比较





## 关键字

#### DISTINCT 

用于过滤掉查询结果中的重复行的关键字

## 函数

### 时间日期

+ `NOW()`：返回当前日期和时间 - datetime
+ `CURDATE()`：返回当前日期 - date
+ `CURTIME()`：返回当前时间 - time
+ `DATE(datetime)`：提取日期时间值中的日期部分 - date
+ `TIME(datetime)`：提取日期时间值中的时间部分 - time
+ `DATE_ADD(datetime, INTERVAL expr unit)`从日期或日期时间值中减去指定的时间间隔
+ `DATE_SUB(datetime, INTERVAL expr unit)` 将指定的时间间隔添加到日期或日期时间值中
+ `DATEDIFF(datetime1,datetime2)`返回datetime2-datetime1的天数差
+ YEAR(datetime) 返回当前年份
+ MONTH(datetime) 返回当前月份(从1开始)
+ DAY(datetime) 返回当前日期天
+ HOUR(datetime) 返回当前小时数
+ MINUTE(datetime) 返回当前分钟数
+ SECOND(datetime) 返回当前秒数

### 字符串

+ 通过正则进行查询 : 

  ```sql
  SELECT * from comment_detail where comment REGEXP '^[是|求]'
  ```

+ SUBSTRING_INDEX(str, delimiter, count)

  + 返回一个 str 的子字符串，在 delimiter 出现 count 次的位置截取。

+ char_length( col )

  + 单位为字符，不管汉字还是数字或者是字母都算是一个字符

+ length( col )

  + 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节

+ replace( col , str1 ,str2)

  + 字符替换, 目前认为不能用正则

### 数字

+ `ABS(num)`: 返回绝对值



### 聚合函数

聚合函数都有哪些

#### sum

0和null的效果是一样的

#### count

null不会追加, 但0会追加



+ union
+ union all



+ limit 限制返回的行数
+ offset 指定查询结果的偏移量, 即从结果集的第几行开始返回数据
+ `DISTINCT` 用于去除重复行




+ inner join : 只返回两个表中满足条件的行, 即只返回匹配的行
+ left join : 返回左表中的所有行，以及与左表中的行匹配的右表中的行
+ right join : 返回右表中的所有行，以及与右表中的行匹配的左表中的行


+ count(column) 多少列
+ sum(column) 所有列相加
+ avg(column) 取平均值
+ round(val, num) 取小数点位数

+ is not null 用于判断不为空
+ like 模糊查询 xxx%





+ UNION 合并 `且` 消除重复行
+ UNION ALL 合并 `不` 消除重复行



+ COALESCE : 用于返回第一个非NULL值

![image-20240219183745304](C:\Users\陈其丰\AppData\Roaming\Typora\typora-user-images\image-20240219183745304.png)

+ CASE WHEN 

![image-20240219183056766](https://chenqf-blog-image.oss-cn-beijing.aliyuncs.com/images/image-20240219183056766.png)







